import Jama.Matrix;
import java.awt.PopupMenu;
import java.io.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Vector;
import javax.swing.*;
import javax.swing.filechooser.FileNameExtensionFilter;
 import java.util.*;  
import java.lang.*;
import static java.lang.Math.round;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

//sfs standard, zrobic wcztywanie od generatora, wiecej niz dwie mozliwosci 


/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * PR_GUI.java
 *
 * Created on 2015-03-05, 19:40:56
 */

/**
 *
 * @author krzy
 */
public class PR_GUI extends javax.swing.JFrame {

    String InData; // dataset from a text file will be placed here
    int ClassCount=0;
    static int  FeatureCount=0;
    public double[][] F, FNew; // original feature matrix and transformed feature matrix
    int[] ClassLabels, SampleCount;
    String[] ClassNames;
    Classifier class1 = new Classifier();
    static int[] Wynik;


    /** Creates new form PR_GUI */
    public PR_GUI() {
        initComponents();
        setSize(720,410);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        rbg_F = new javax.swing.ButtonGroup();
        b_read = new javax.swing.JButton();
        jPanel2 = new javax.swing.JPanel();
        l_dataset_name_l = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        l_dataset_name = new javax.swing.JLabel();
        l_nfeatures = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        selbox_nfeat = new javax.swing.JComboBox();
        f_combo_criterion = new javax.swing.JComboBox();
        jLabel10 = new javax.swing.JLabel();
        b_deriveFS = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        jPanel4 = new javax.swing.JPanel();
        jLabel8 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        jComboBox2 = new javax.swing.JComboBox();
        b_Train = new javax.swing.JButton();
        jButton4 = new javax.swing.JButton();
        jLabel16 = new javax.swing.JLabel();
        tf_TrainSetSize = new javax.swing.JTextField();
        jLabel17 = new javax.swing.JLabel();
        f_combo_criterion1 = new javax.swing.JComboBox();
        jLabel11 = new javax.swing.JLabel();
        jLabel1 = new javax.swing.JLabel();
        textArea1 = new java.awt.TextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        getContentPane().setLayout(null);

        b_read.setText("Wybierz plik z danymi");
        b_read.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                b_readActionPerformed(evt);
            }
        });
        getContentPane().add(b_read);
        b_read.setBounds(10, 20, 160, 30);

        jPanel2.setBackground(new java.awt.Color(204, 255, 255));
        jPanel2.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        l_dataset_name_l.setText("Nazwa");

        jLabel4.setText("Cechy");

        l_dataset_name.setText("...");

        l_nfeatures.setText("...");

        jLabel6.setText("Ilość cech");

        selbox_nfeat.setMaximumRowCount(10);
        selbox_nfeat.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }));
        selbox_nfeat.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                selbox_nfeatItemStateChanged(evt);
            }
        });
        selbox_nfeat.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                selbox_nfeatActionPerformed(evt);
            }
        });

        f_combo_criterion.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Normal", "SFS" }));
        f_combo_criterion.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                f_combo_criterionActionPerformed(evt);
            }
        });

        jLabel10.setText("Sposób liczenia");

        b_deriveFS.setText("Oblicz wsp. Fishera");
        b_deriveFS.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                b_deriveFSActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                .addGap(25, 25, 25)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel10)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(jLabel6, javax.swing.GroupLayout.PREFERRED_SIZE, 63, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(selbox_nfeat, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(jLabel4)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(l_nfeatures))
                    .addComponent(f_combo_criterion, javax.swing.GroupLayout.PREFERRED_SIZE, 140, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(l_dataset_name_l)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(l_dataset_name))
                    .addComponent(b_deriveFS, javax.swing.GroupLayout.PREFERRED_SIZE, 269, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(344, 344, 344))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(l_dataset_name_l)
                    .addComponent(l_dataset_name))
                .addGap(18, 18, 18)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel4)
                    .addComponent(l_nfeatures))
                .addGap(38, 38, 38)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(selbox_nfeat, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel6))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 19, Short.MAX_VALUE)
                .addComponent(jLabel10)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(f_combo_criterion, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(34, 34, 34)
                .addComponent(b_deriveFS)
                .addGap(35, 35, 35))
        );

        getContentPane().add(jPanel2);
        jPanel2.setBounds(20, 80, 310, 270);

        jButton2.setText("Wczytaj dane");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });
        getContentPane().add(jButton2);
        jButton2.setBounds(180, 20, 150, 30);

        jPanel4.setBackground(new java.awt.Color(204, 255, 204));
        jPanel4.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        jPanel4.setLayout(null);

        jLabel8.setFont(new java.awt.Font("Comic Sans MS", 0, 18)); // NOI18N
        jLabel8.setText("Klasyfikatory");
        jPanel4.add(jLabel8);
        jLabel8.setBounds(70, 0, 210, 26);

        jLabel9.setText("Metoda");
        jPanel4.add(jLabel9);
        jLabel9.setBounds(14, 44, 36, 14);

        jComboBox2.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Nearest neighbor (NN)", "Nearest Mean (NM)", "Nearest Mean (NM-OM)", "k-Nearest Neighbor (k-NN)", "k-Nearest Mean (k-NM)", "CROSSVALIDATION" }));
        jComboBox2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboBox2ActionPerformed(evt);
            }
        });
        jPanel4.add(jComboBox2);
        jComboBox2.setBounds(74, 41, 150, 20);

        b_Train.setText("Wczytaj dane");
        b_Train.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                b_TrainActionPerformed(evt);
            }
        });
        jPanel4.add(b_Train);
        b_Train.setBounds(30, 90, 140, 23);
        b_Train.getAccessibleContext().setAccessibleName("Wczytaj dane");
        b_Train.getAccessibleContext().setAccessibleDescription("");

        jButton4.setText("Oblicz");
        jButton4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton4ActionPerformed(evt);
            }
        });
        jPanel4.add(jButton4);
        jButton4.setBounds(200, 90, 120, 23);

        jLabel16.setText("Rozmiar zb. tren.");
        jPanel4.add(jLabel16);
        jLabel16.setBounds(10, 130, 100, 14);

        tf_TrainSetSize.setText("80");
        tf_TrainSetSize.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                tf_TrainSetSizeActionPerformed(evt);
            }
        });
        jPanel4.add(tf_TrainSetSize);
        tf_TrainSetSize.setBounds(100, 130, 20, 20);

        jLabel17.setText("%");
        jPanel4.add(jLabel17);
        jLabel17.setBounds(130, 130, 20, 14);

        f_combo_criterion1.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "1", "2", "3", "4", "5" }));
        f_combo_criterion1.setSelectedItem(1);
        f_combo_criterion1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                f_combo_criterion1ActionPerformed(evt);
            }
        });
        jPanel4.add(f_combo_criterion1);
        f_combo_criterion1.setBounds(250, 40, 50, 20);

        jLabel11.setText("Wartość n");
        jPanel4.add(jLabel11);
        jLabel11.setBounds(250, 20, 49, 14);

        getContentPane().add(jPanel4);
        jPanel4.setBounds(340, 20, 350, 180);

        jLabel1.setFont(new java.awt.Font("Comic Sans MS", 0, 18)); // NOI18N
        jLabel1.setText("Wyniki");
        getContentPane().add(jLabel1);
        jLabel1.setBounds(350, 210, 54, 26);
        getContentPane().add(textArea1);
        textArea1.setBounds(350, 250, 350, 100);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void b_readActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_b_readActionPerformed
        // reads in a text file; contents is placed into a variable of String type
        InData = readDataSet();
    }//GEN-LAST:event_b_readActionPerformed

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        // Analyze text inputted from a file: determine class number and labels and number
        // of features; build feature matrix: columns - samples, rows - features
        try {
            if(InData!=null) {
                getDatasetParameters();
                l_nfeatures.setText(FeatureCount+"");
                fillFeatureMatrix();
            }
        } catch (Exception ex) {
            JOptionPane.showMessageDialog(this,ex.getMessage());
        }
        
    }//GEN-LAST:event_jButton2ActionPerformed

    private void b_deriveFSActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_b_deriveFSActionPerformed
        // derive optimal feature space
        if(F==null) return;
        if(selbox_nfeat.getSelectedItem().toString().equals("1")){
            
      
            selectFeatures();
          
            //selectFeatures(flags,Integer.parseInt((String)selbox_nfeat.getSelectedItem()));
        }
        else if(f_combo_criterion.getSelectedItem().toString().equals("Normal")){
        fisherek(Integer.parseInt(selbox_nfeat.getSelectedItem().toString()));
        }
         else if(f_combo_criterion.getSelectedItem().toString().equals("SFS")){
            SFS(Integer.parseInt(selbox_nfeat.getSelectedItem().toString()));
        }
        
       
       
    }//GEN-LAST:event_b_deriveFSActionPerformed

    private void b_TrainActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_b_TrainActionPerformed
        
        // first step: split dataset (in new feature space) into training / testing parts

      // if(FNew==null) return; 
        
       generateTraining_and_Test_Sets(Wynik);

        // no reduced feature space have been derived
      //  Classifier Cl = new Classifier();
        // Classifier.generateTraining_and_Test_Sets(FNew, tf_TrainSetSize.getText());
        

    }//GEN-LAST:event_b_TrainActionPerformed

    private void tf_TrainSetSizeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_tf_TrainSetSizeActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_tf_TrainSetSizeActionPerformed

    private void jButton4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton4ActionPerformed

            String wskaźnik  = jComboBox2.getSelectedItem().toString() ;
           
            int ilosc = Integer.parseInt(f_combo_criterion1.getSelectedItem().toString());
          
           if(wskaźnik.contains("Nearest neighbor (NN)")){
               
               NN();
               //genZbirBOOT();
          // fisherek();
            //SFS(3);
           
           }
           else if (wskaźnik.contains("Nearest Mean (NM)")){NM(0);}
            else if (wskaźnik.contains("Nearest Mean (NM-OM)")){NM(1);}
           else if (wskaźnik.contains("k-Nearest Neighbor (k-NN)")){kNN(ilosc);}
           else if (wskaźnik.contains("k-Nearest Mean (k-NM)")){kNM(ilosc);}
           else if (wskaźnik.contains("CROSSVALIDATION")){genZbirBOOT();}
  
    }//GEN-LAST:event_jButton4ActionPerformed

    private void jComboBox2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jComboBox2ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jComboBox2ActionPerformed

    private void selbox_nfeatActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_selbox_nfeatActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_selbox_nfeatActionPerformed

    private void f_combo_criterionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_f_combo_criterionActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_f_combo_criterionActionPerformed

    private void selbox_nfeatItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_selbox_nfeatItemStateChanged
       
    }//GEN-LAST:event_selbox_nfeatItemStateChanged

    private void f_combo_criterion1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_f_combo_criterion1ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_f_combo_criterion1ActionPerformed

    /**
    * @param args the command line arguments
    */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new PR_GUI().setVisible(true);
                
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton b_Train;
    private javax.swing.JButton b_deriveFS;
    private javax.swing.JButton b_read;
    private javax.swing.JComboBox f_combo_criterion;
    private javax.swing.JComboBox f_combo_criterion1;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton4;
    private javax.swing.JComboBox jComboBox2;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel16;
    private javax.swing.JLabel jLabel17;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JLabel l_dataset_name;
    private javax.swing.JLabel l_dataset_name_l;
    private javax.swing.JLabel l_nfeatures;
    private javax.swing.ButtonGroup rbg_F;
    public javax.swing.JComboBox selbox_nfeat;
    private java.awt.TextArea textArea1;
    private javax.swing.JTextField tf_TrainSetSize;
    // End of variables declaration//GEN-END:variables

    private String readDataSet() {

        String s_tmp, s_out="";
        JFileChooser jfc = new JFileChooser();
        jfc.setCurrentDirectory(new File(".."));
        FileNameExtensionFilter filter = new FileNameExtensionFilter(
                                            "Datasets - plain text files", "txt");
        jfc.setFileFilter(filter);
        if(jfc.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            try {
                BufferedReader br = new BufferedReader(new FileReader(jfc.getSelectedFile()));
                while((s_tmp=br.readLine())!=null) s_out += s_tmp + '$';
                br.close();
                l_dataset_name.setText(jfc.getSelectedFile().getName());
            } catch (Exception e) {        }
        }
        return s_out;
    }

    private void getDatasetParameters() throws Exception{
        // based on data stored in InData determine: class count and names, number of samples 
        // and number of features; set the corresponding variables
        String stmp=InData, saux="";
        // analyze the first line and get feature count: assume that number of features
        // equals number of commas
        saux = InData.substring(InData.indexOf(',')+1, InData.indexOf('$'));
        if(saux.length()==0) throw new Exception("The first line is empty");
        // saux stores the first line beginning from the first comma
        int count=0;
        while(saux.indexOf(',') >0){
            saux = saux.substring(saux.indexOf(',')+1);            
            count++;
        }
        FeatureCount = count+1; // the first parameter
        // Determine number of classes, class names and number of samples per class
        boolean New;
        int index=-1;
        List<String> NameList = new ArrayList<String>();
        List<Integer> CountList = new ArrayList<Integer>();
        List<Integer> LabelList = new ArrayList<Integer>();
        while(stmp.length()>1){
            saux = stmp.substring(0,stmp.indexOf(' '));
            New = true; 
            index++; // new class index
            for(int i=0; i<NameList.size();i++) 
                if(saux.equals(NameList.get(i))) {
                    New=false;
                    index = i; // class index
                }
            if(New) {
                NameList.add(saux);
                CountList.add(0);
            }
            else{
                CountList.set(index, CountList.get(index).intValue()+1);
            }           
            LabelList.add(index); // class index for current row
            stmp = stmp.substring(stmp.indexOf('$')+1);
        }
        // based on results of the above analysis, create variables
        ClassNames = new String[NameList.size()];
        for(int i=0; i<ClassNames.length; i++)
            ClassNames[i]=NameList.get(i);
        SampleCount = new int[CountList.size()];
        for(int i=0; i<SampleCount.length; i++)
            SampleCount[i] = CountList.get(i).intValue()+1;
        ClassLabels = new int[LabelList.size()];
        for(int i=0; i<ClassLabels.length; i++)
            ClassLabels[i] = LabelList.get(i).intValue();
    }

    private void fillFeatureMatrix() throws Exception {
        // having determined array size and class labels, fills in the feature matrix
        int n = 0;
        String saux, stmp = InData;
        for(int i=0; i<SampleCount.length; i++)
            n += SampleCount[i];
        if(n<=0) throw new Exception("no samples found");
        F = new double[FeatureCount][n]; // samples are placed column-wise
        for(int j=0; j<n; j++){
            saux = stmp.substring(0,stmp.indexOf('$'));
            saux = saux.substring(stmp.indexOf(',')+1);
            for(int i=0; i<FeatureCount-1; i++) {
                F[i][j] = Double.parseDouble(saux.substring(0,saux.indexOf(',')));
                saux = saux.substring(saux.indexOf(',')+1);
            }
            F[FeatureCount-1][j] = Double.parseDouble(saux);
            stmp = stmp.substring(stmp.indexOf('$')+1);
        }
        int cc = 1;
    }
    
    
    ////////////////////////////Dokonujemy podzialu danych/////////////////////////
    
    double[][] Treningowy, Testowy,TreningowyA, TreningowyB;
    int [] TreningowyPrzynaleznosc, TestowyPrzynaleznosc;
   
    
    void generateTraining_and_Test_Sets(int[] Wynik){
       
        
          double StosZbiorow = Double.parseDouble(tf_TrainSetSize.getText()) / 100.0;
          int TrenA = (int) round(SampleCount[0] * StosZbiorow);
          int TestA = SampleCount[0] - TrenA;
          int TrenB = (int) round(SampleCount[1] * StosZbiorow);
          int TestB = SampleCount[1] - TrenB;
          int counterA=0, counterB=0;
      
         Treningowy = new double[Wynik.length][TrenA+TrenB];
         Testowy = new double[Wynik.length][TestA+TestB];
         TreningowyA = new double[Wynik.length][TrenA];
         TreningowyB = new double[Wynik.length][TrenB];
         
         
         TreningowyPrzynaleznosc = new int[TrenA+TrenB]; 
         TestowyPrzynaleznosc= new int[TestA+TestB]; 
      
        for (int i = 0; i < Wynik.length; i++) {
            counterA=0;
            counterB=0;
            for (int j = 0; j < F[i].length; j++) {

                if (ClassLabels[j] == 0) {
                    if (j < TrenA ) {
                      Treningowy[i][j] = F[Wynik[i]][j];
                      TreningowyA[i][counterA] = F[Wynik[i]][j];
                      TreningowyPrzynaleznosc[j]=0;
                      counterA++;
                    } 
                    else {
                        Testowy[i][j - TrenA ] = F[Wynik[i]][j];
                        TestowyPrzynaleznosc[j - TrenA ]=0;
                    }
                }

                if (ClassLabels[j] == 1) {
                    if (j < (TrenB + TrenA  + TestA)) {
                        Treningowy[i][(j - TestA)] = F[Wynik[i]][j];
                        TreningowyB[i][(counterB)] = F[Wynik[i]][j];
                         TreningowyPrzynaleznosc[j - TestA]=1;
                         counterB++;
                    } else {
                      Testowy[i][(j - TrenB - TrenA )] = F[Wynik[i]][j];
                      TestowyPrzynaleznosc[j - TrenB - TrenA]=1;

                    }
     
                }
           
            }
        }
      

       
    }
    
    
    //////////////////////////////////Klasyfikator NN///////////////////////////
    
    
    public void NN(){
        
        int znacznik=0;
        double result=0,win=0,poprawnosc=0;
        
        
        ////////Liczymy dla kazdego punktu odleglosc i wybieramy najmniejsza
        for(int i=0; Testowy[0].length>i;i++){
            for(int j=0; Treningowy[0].length>j;j++){
                for(int k=0; (Testowy.length)>k;k++){
                 
                    result =result+Math.pow(Testowy[k][i]-Treningowy[k][j],2);
                }
       
            result=Math.sqrt(result);
            
            if(win==0){
                win=result;
                znacznik=TreningowyPrzynaleznosc[j];
            }
            else if(result<win){
                win=result;
                znacznik=TreningowyPrzynaleznosc[j];
            }
            result=0;
       }
           
            if(znacznik==TestowyPrzynaleznosc[i]){poprawnosc++;};
            win=0;
            
    }
        
    double wynik=(poprawnosc/Testowy[0].length)*100; 
    textArea1.setText("Wynik dla NN:\nPoprawnych = "+poprawnosc+"\nProcentowo:"+wynik+" %");
    
    }
    
    ///////////////////////////////////Klasyfikator NM oraz NM-OM///////////////////////////////
    
       public void NM(int switcher){
           
          int znacznik=0;
        double result=0,win=0,poprawnosc=0, sredniaA=0,sredniaB=0,countA=0,countB=0;
        
       
        
        //////////NM przy pomocy Mahalanobisa
         if(switcher==1){
              textArea1.setText("Prosze czekac...");
                         
            double poprawnoscM=0;
            int winM=0;
            double vec[]= new double[Testowy.length];

            //przechodzimy po klasach i wybieramy lepszy wynik
            
             for(int i=0; Testowy[0].length>i;i++){
                for(int j=0; Testowy.length>j;j++){
                    vec[j]=Testowy[j][i];
                }   
                    if(distance(TreningowyA, vec)<distance(TreningowyB, vec)){
                      
                        winM=0;
                    }
                    else
                    {
                       winM=1;
                    }
                    if(winM==TestowyPrzynaleznosc[i]){poprawnoscM++;}; 
            }

            double wynik=(poprawnoscM/Testowy[0].length)*100;
          
           textArea1.setText("Wynik dla NM-OM:\nPoprawnych = "+poprawnosc+"\nProcentowo:"+wynik+" %");
        
        }
         /// Normalny NM
        else{
  
             /////////////////////////dla punktu testowgo liczymy odleglosci i porownujemy srednie
        for(int i=0; Testowy[0].length>i;i++){
            for(int j=0; Treningowy[0].length>j;j++){
                for(int k=0; (Testowy.length)>k;k++){
                 
                    result =result+Math.pow(Testowy[k][i]-Treningowy[k][j],2);
                }
       
            result=Math.sqrt(result);
            
            if (TreningowyPrzynaleznosc[j]==0)
            {
                sredniaA=sredniaA+result;
                countA++;
            }
            else{
                sredniaB=sredniaB+result;
                countB++;
            }
           
            result=0;
       }
            sredniaA=sredniaA/countA;
            sredniaB=sredniaB/countB;
            
                if(sredniaA<sredniaB){
                win=sredniaA;
                znacznik=0;
            }
            else{
                 win=sredniaB;
                 znacznik=1;
            }
           
            if(znacznik==TestowyPrzynaleznosc[i]){poprawnosc++;};
            
            win=0;
            sredniaA=0;
            sredniaB=0;
             countA=0;
              countB=0;
            
        }
         double wynik=(poprawnosc/Testowy[0].length)*100;
              
            textArea1.setText("Wynik dla NM:\nPoprawnych = "+poprawnosc+"\nProcentowo:"+wynik+" %");
         
         }
       }
       
 
      ///////////////////////////////////////////////////Liczy odleglosc Mahalanobisa//////////////////////
       
   public static double distance(double[][] m1, double v1[]) {
       
   	double[] srednia = new double[m1.length];
   	double[][] V= new double[m1.length][1];
   	double dlSredniej=m1[0].length;
   	double result=0;
   	double detD=0;
         double[][] m= new double[m1.length][m1[0].length];
         
   	 //sumujemy do sredniej i liczymy jej wartosc
   	for(int i=0; m1.length>i;i++){
   	for(int j=0; m1[0].length>j;j++){
        	srednia[i]=srednia[i]+m1[i][j];
   	}
   	srednia[i]=srednia[i]/dlSredniej;
   	}
        
   	//odejmujemy srednija od wartosci
   	for(int i=0; m1.length>i;i++){
   	for(int j=0; m1.length>j;j++){
   	m[i][j]=m1[i][j]-srednia[i];        
   	}
   	}

       Matrix A = new Matrix(m);
       double[][] m2= new double[m1.length][m1.length];
        double[][] m3= new double[m1.length][m1.length];
       double te = 1.0/m1[0].length;

       //macierz razy transponowana i razy 1/liczbe elementów(chwilowo te)
       Matrix Aa =A.times(A.transpose()).times(te);
      

      //zamieniamy na tablice
       for(int i=0; m1.length>i;i++){
   	for(int j=0; m1.length>j;j++){
   	m2[i][j]=Aa.get(i, j);
        
   	}
   	}
 
       //liczymy det do tablicy
       detD=determinant(m2);

        
       //od wektora odejmujemy srednie
       for(int i=0; v1.length>i;i++){
   	   V[i][0]=v1[i]-srednia[i];
   	}
       
   	double[][] temp= new double[m2.length-1][m2.length-1];
   	
       //pokazdym elemencie przechodzimy i liczymy dla niego nowa wartosc
       for(int i=0; m2.length>i;i++){
   	for(int j=0; m2[0].length>j;j++){
   	
   	//usuwamy niechciany w danej chwili wiersz i kolumne i dla reszty liczymy deta
   	for(int k=0; m2.length>k;k++){
   	    for(int l=0; m2[0].length>l;l++){
                
   	    if(k!=i && l!=j){
                 if (k>i && l>j){
            temp[k-1][l-1]=m2[k][l];   
            }
                 else if(k>i){
            temp[k-1][l]=m2[k][l];   
            }
                else if (l>j){
            temp[k][l-1]=m2[k][l];   
            }
                          
            else{
   	    temp[k][l]=m2[k][l];
   	    } 
            }                
   	    }
   	}
   	m3[i][j]=determinant(temp);
   	        
   	}
   	}
       //konwertujemy na macierze
       Matrix R = new Matrix(m3);
        
       Matrix Vv = new Matrix(V);
      
       Matrix Res ;

       //ostatecznie obliczamy macierz odwrotna
       Matrix RR =R.transpose().times(1/detD);
       
       //vektor razy odwrocona razy wektor trans.
       Res= Vv.transpose().times(RR).times(Vv);
  
       //przypisujemy wynik do zmiennej
       for(int i=0; Res.getRowDimension()>i;i++){
   	for(int j=0; Res.getColumnDimension()>j;j++){
   	result=Res.get(i, j);
   
       
   	}
       }

       return Math.pow(result,2);
       

}   
   
   public static double determinant(double[][] matrix){ 
       double sum=0; 
       double s;
       //czy ma 1 wymiar
       if(matrix.length==1){  
         return(matrix[0][0]);
       }
       //przelatujemy powszystkich wierszach
       for(int i=0;i<matrix.length;i++){ 
          // tablica z wynikami do zsumowania
         double[][]smaller= new double[matrix.length-1][matrix.length-1]; 
         for(int a=1;a<matrix.length;a++){
           for(int b=0;b<matrix.length;b++){
             if(b<i){
               smaller[a-1][b]=matrix[a][b];
             }
             else if(b>i){
               smaller[a-1][b-1]=matrix[a][b];
             }
           }
         }
         if(i%2==0){ 
           s=1;
         }
         else{
           s=-1;
         }
         sum+=s*matrix[0][i]*(determinant(smaller)); 
       }
       return(sum); 
     }
       
       ////////////////////////////////Klasyfikator kNN////////////////////////////////
       
       public void kNN(int kwyg){
           
        int counterwypelnienia=0; 
        int znacznik=0;
        double[] tabwin = new double[kwyg];
        int[] tabwinznacznik = new int[kwyg];
        double result=0,winA=0, winB=0,poprawnosc=0;
        
  
  
        ////Liczymy odleglosi analogicznie jak wczesniej i wybieramy k najlepszych i sprawdzamy czy 0 czy 1 jest wiecej
        
        for(int i=0; Testowy[0].length>i;i++){
            for(int j=0; Treningowy[0].length>j;j++){
                for(int k=0; (Testowy.length)>k;k++){
                 
                    result =result+Math.pow(Testowy[k][i]-Treningowy[k][j],2);
                }
       
            result=Math.sqrt(result);
            
            if(counterwypelnienia<kwyg){
                tabwin[counterwypelnienia]=result;
                tabwinznacznik[counterwypelnienia]=TreningowyPrzynaleznosc[j];
                counterwypelnienia++;
                  
            }
            else { 
                         
                sortowaniezwy(tabwin, tabwinznacznik );
                if( tabwin[kwyg-1]>result){
                tabwin[kwyg-1]=result;
                tabwinznacznik[kwyg-1]=TreningowyPrzynaleznosc[j];
                }
            }
            result=0; 
            }
            sortowaniezwy(tabwin, tabwinznacznik );
            
            for (int t=0;tabwinznacznik.length>t;t++)
            {
                if(tabwinznacznik[t]==0){
                    winA++;
                 }
                else{
                 winB++;
                 }
                }
                if (winA>winB){
                     znacznik=0;
                 }else{
                    znacznik=1;
                 }      
            if(znacznik==TestowyPrzynaleznosc[i]){poprawnosc++; };
            winA=0;
            winB=0;
              counterwypelnienia=0;  
    }
        
    double wynik=(poprawnosc/Testowy[0].length)*100;
    textArea1.setText("Wynik dla k-NN:\nPoprawnych = "+poprawnosc+"\nProcentowo:"+wynik+" %");
    
    }

       ///Sortuje tablice z wygranymi
       
      public void sortowaniezwy(double[] tablicaWygranych, int[] TablicaZnacznikow){
          
        int wczesniejsza = tablicaWygranych.length - 1; 
        int pozniejsza = wczesniejsza - 1; 

        double tmp;
        int tmp2;
        while (pozniejsza >= 0) 
        {
            if (tablicaWygranych[pozniejsza] > tablicaWygranych[wczesniejsza]) 
            {
                tmp = tablicaWygranych[pozniejsza];
                tablicaWygranych[pozniejsza] = tablicaWygranych[wczesniejsza]; 
                tablicaWygranych[wczesniejsza] = tmp;

                tmp2 = TablicaZnacznikow[pozniejsza];
                TablicaZnacznikow[pozniejsza] = TablicaZnacznikow[wczesniejsza]; 
                TablicaZnacznikow[wczesniejsza] = tmp2;

                wczesniejsza = tablicaWygranych.length - 1;  
                pozniejsza = wczesniejsza - 1;  
            } else 
            {
                wczesniejsza--;
                pozniejsza--;
            }
        }
      }
  
      
      //////////////////////////Klasyfikator k-NM////////////////////////////////
      
       public void kNM(int liczpodklas){
      
       
        double tablicaSrA[][] = new double[TreningowyA.length][liczpodklas];
        double tablicaSrB[][]= new double[TreningowyB.length][liczpodklas];
        double poprzednia[][]= new double[TreningowyA.length][liczpodklas],temSr=0;
        int wyniki[][]= new int[liczpodklas][];
        int wynikiTem[][]= new int[liczpodklas][TreningowyB[0].length];
        int wynikiTemPoj[]= new int[liczpodklas];
        
        
        double pomocnik=100;
        int losA=0, winsort=0,counter=0,iii=0;
        int losB=0,t=0;
        double result=0, win[]=new double[liczpodklas],winznacznik[]=new double[liczpodklas];
        Random generator = new Random(); 
        boolean stroz=true;
      
       
        
        ////losuje i wpisuje do tablicy srednich 
        for(int i=0;i<liczpodklas;i++){
            losA = generator.nextInt(TreningowyA.length) ;
        
            for(int j=0;TreningowyA.length>j;j++){
                tablicaSrA[j][i]=TreningowyA[j][losA];  
            }
            
            losB = generator.nextInt(TreningowyB.length);
            for(int j=0;(TreningowyB.length)>j;j++){
                tablicaSrB[j][i]=TreningowyB[j][losB];  
            }        
        }
        
       //  rozpoczyna petle ktora bedzie liczyc do skutku wartosci
        do{
            stroz=true;
            t=0;
            
            //kopiuje tablice do tablicy w celu ich pozniejszego porownania
            for(int i=0; tablicaSrA[0].length>i;i++){
                for(int j=0; tablicaSrA.length>j;j++){
                    poprzednia[j][i]=tablicaSrA[j][i];
                }
            }
            for(int tt=0;tt<wynikiTemPoj.length;tt++){
                wynikiTemPoj[tt]=0;
            }
            //Liczy odleglosi dla kazdego punktu
            for(int i=0; TreningowyA[0].length>i;i++){
                for(int j=0; tablicaSrA[0].length>j;j++){
                    result=0;
                    winsort=100;
                    for(int k=0; TreningowyA.length>k;k++){
                        result =result+Math.pow(tablicaSrA[k][j]-TreningowyA[k][i],2);   
                    }
                    result=Math.sqrt(result);
                    win[j]=result;
                }
                    for(int r=0; r<win.length;r++){
                        if(win[r]<pomocnik){
                            pomocnik=win[r];
                            winsort=r;
                        }
                    }
                    pomocnik=100;
                 //wpisuje wartoscy najmniejszych odleglosci do tablicy wygranych

        for(int tt=0;tt<wynikiTemPoj.length;tt++){
            
            if(tt==winsort){
                
                wynikiTem[tt][wynikiTemPoj[tt]]=i;
                wynikiTemPoj[tt]+=1;
            }
                        
        }
            }
            
          for(int tt=0;tt<wynikiTemPoj.length;tt++){
            
            if(wynikiTemPoj[tt]==0){
                
                wynikiTem[tt][0]=0;
                wynikiTemPoj[tt]=1;
                
            }
                        
        }
            
            
            
            
        for(int tt=0;tt<wynikiTemPoj.length;tt++){
        wyniki[tt]=new int[wynikiTemPoj[tt]];
        }

        for(int tt=0;tt<wynikiTem.length;tt++){
            for(int tt3=0;tt3<wynikiTemPoj[tt];tt3++){
                wyniki[tt][tt3] =wynikiTem[tt][tt3];

            }      
        }

         //liczy srednie 
        for(int d=0; tablicaSrA[0].length>d;d++){
           for(int k=0; tablicaSrA.length>k;k++){
                for(int i=0; wyniki[d].length>i;i++){
                    t=wyniki[d][i];
                    temSr= temSr+TreningowyA[k][t];
                } 
            tablicaSrA[k][d]=temSr/wyniki[d].length;
            temSr=0;
            } 
        }
        //sprawdzamy czy nowe tablice sa podobne do poprzednich
        for(int d=0; tablicaSrA[0].length>d;d++){
            for(int k=0; tablicaSrA.length>k;k++){
           
                if(tablicaSrA[k][d]>1.3*poprzednia[k][d] || tablicaSrA[k][d]<0.7*poprzednia[k][d] || Double.isNaN(tablicaSrA[k][d]) || Double.isNaN(poprzednia[k][d]) ){
                    stroz=false;
                }
            }
        }
        }while(stroz==false);
        
        //////////////////////////////Teraz do B/////////////////////////////////

        do{
            stroz=true;
            t=0;
            //kopiuje tablice fo tablicy w celu ich pozniejszego porownania
            for(int i=0; tablicaSrB[0].length>i;i++){
                for(int j=0; tablicaSrB.length>j;j++){
                    poprzednia[j][i]=tablicaSrB[j][i];
                }
            }
             for(int tt=0;tt<wynikiTemPoj.length;tt++){
                wynikiTemPoj[tt]=0;
            }
            //Liczy odleglosi dla kazdego punktu
            for(int i=0; TreningowyB[0].length>i;i++){
                for(int j=0; tablicaSrB[0].length>j;j++){
                    result=0;
                   
                    for(int k=0; TreningowyB.length>k;k++){
                        result =result+Math.pow(tablicaSrB[k][j]-TreningowyB[k][i],2);   
                    }
                    result=Math.sqrt(result);
                    win[j]=result;
                }
                    for(int r=0; r<win.length;r++){
                      if(win[r]<pomocnik){
                            pomocnik=win[r];
                            winsort=r;
                        }
                        
                    }
                        pomocnik=100;
                 //wpisuje wartoscy najmniejszych odleglosci do tablicy wygranych
      
        for(int tt=0;tt<wynikiTemPoj.length;tt++){
            
            if(tt==winsort){
                
                wynikiTem[tt][wynikiTemPoj[tt]]=i;
                wynikiTemPoj[tt]+=1;
            }               
        }
            }
            
              for(int tt=0;tt<wynikiTemPoj.length;tt++){
            
            if(wynikiTemPoj[tt]==0){
                
                wynikiTem[tt][0]=0;
                wynikiTemPoj[tt]=1;
                
            }
              }
            
        for(int tt=0;tt<wynikiTemPoj.length;tt++){
        wyniki[tt]=new int[wynikiTemPoj[tt]];
        }
        
        
        for(int tt=0;tt<wynikiTem.length;tt++){
            for(int tt3=0;tt3<wynikiTemPoj[tt];tt3++){
                wyniki[tt][tt3] =wynikiTem[tt][tt3];
            }
        
        }
               
         //liczy srednie 
        for(int d=0; tablicaSrB[0].length>d;d++){
           for(int k=0; tablicaSrB.length>k;k++){
                for(int i=0; wyniki[d].length>i;i++){
                    t=wyniki[d][i];
                    temSr= temSr+TreningowyB[k][t];
                } 
            tablicaSrB[k][d]=temSr/wyniki[d].length;
            temSr=0;
            } 
        }
        //sprawdzamy czy nowe tablice sa podobne do poprzednich
        for(int d=0; tablicaSrB[0].length>d;d++){
            for(int k=0; tablicaSrB.length>k;k++){
                                            
                if(tablicaSrB[k][d]>1.3*poprzednia[k][d] || tablicaSrB[k][d]<0.7*poprzednia[k][d] || Double.isNaN(tablicaSrB[k][d]) || Double.isNaN(poprzednia[k][d]) ){
                    stroz=false;
                }
            }
        }
        }while(stroz==false);
        
        ///////////////////////Liczymy odleglosci oraz poprawnosc/////////////
        
        
        int znacznik=0;
        double winAll=0,poprawnosc=0,resultA=0,resultB=0,winA=100,winB=100,wintemp=0;
        ArrayList <Double> wygraneA =  new ArrayList<Double>();
        ArrayList <Double> wygraneB =  new ArrayList<Double>();

  
        for(int i=0; Testowy[0].length>i;i++){
            for(int j=0; tablicaSrB[0].length>j;j++){
                for(int k=0; (tablicaSrB.length)>k;k++){
                 
                    resultA =resultA+Math.pow(Testowy[k][i]-tablicaSrA[k][j],2);
                    resultB =resultB+Math.pow(Testowy[k][i]-tablicaSrB[k][j],2);
                }
       
            resultA=Math.sqrt(resultA);
            resultB=Math.sqrt(resultB);
            wygraneA.add(resultA);
            wygraneB.add(resultB);
            resultA=0;
            resultB=0;
            }
            
            for(Double item:wygraneA){
                if (item<winA)
                    winA=item;
            }
             for(Double item:wygraneB){
               
                if (item<winB)
                    winB=item;
            }
            if(winA<winB){
                winAll=winA;
                znacznik=0;
            }
            else if(winB<=winA){
                winAll=winB;
                znacznik=1;
            }
            if(znacznik==TestowyPrzynaleznosc[i]){poprawnosc++;};
            winA=100;
            winB=100;
            wygraneA.clear();
            wygraneB.clear();
            
    }
        
    double wynik=(poprawnosc/Testowy[0].length)*100;
    
    textArea1.setText("Wynik dla k-NM:\nPoprawnych = "+poprawnosc+"\nProcentowo:"+wynik+" %");
        
        
        
    }
       //////////////////////Wspólczynnik fishera//////////////////////////////
       /////////////////////Generujemy klasy tylko 0 i 1///////////////////////////////////

   
    double FA2[][]=new double[64][176]; 
    static double FB2[][]=new double[64][608];
   
    void genKlas(int ilosc){ 
        
   
          double FA[][] = new double[F.length][SampleCount[0]];
           double FB[][] = new double[F.length][SampleCount[1]];
        
       
         int counterA=0,counterB=0;
     
        for (int i = 0; i < F.length; i++) {
            counterA=0;
            counterB=0;
            for (int j = 0; j < F[i].length; j++) {

                if (ClassLabels[j] == 0) {
                    
                     FA[i][counterA]=F[i][j];
                     counterA++;
                    
                }

                if (ClassLabels[j] == 1) {
                  FB[i][counterB]=F[i][j];
                     counterB++;
     
                }
           
            }
        }
        
       
        

        double wynt=0;
        int[] temp = new int[ilosc];
        double Wygrana = 100;
        int wyIndex = 0,naraz=0;
        
      
       
           for(int k=0; k<FA.length;k++){
            for (int j=0; j<FA[k].length;j++){      
		FA2[k][j]=FA[k][j]; 
            }
       }
       
        for(int l=0; l<FB.length;l++){
          for (int j=0; j<FB[l].length;j++){
		FB2[l][j]=FB[l][j]; 
            }
       }
    }   
       
      ///////////////////////////////Funkcjia odpowiada za wybieranie najlepszego fishera
   void fisherek(int ilosc){  

     
        genKlas(ilosc);
           
      
    
    
        int[][] Wkomp2 = genMozliwosci(ilosc);
        double wynt=0;
        int[] temp = new int[ilosc];
        double Wygrana = 100;
        int wyIndex = 0,naraz=0;
        
      
      
         for (int i = 0; i < Wkomp2.length; i++) {
            for (int j = 0; j < Wkomp2[i].length; j++) {
                    temp[j]=Wkomp2[i][j];
       
                        }
          
            wynt=obliczanieFisherka(temp);
          
           
        
           if(naraz==0){
               naraz++;
               Wygrana=wynt;
               }
               
            if(Wygrana<wynt){
            
            Wygrana=wynt;
            wyIndex=i;
            }
           
         }
       Wynik = new int[Wkomp2[wyIndex].length]; 
     
          String wyniki="Klasyfikacjia normalna\n\nWygrały nastepujące cechy:   ";
           for (int i = 0; i < Wkomp2[wyIndex].length; i++) {
         
               wyniki+=Wkomp2[wyIndex][i]+" ";
               Wynik[i]=Wkomp2[wyIndex][i];
            
               
           
           }
           
           textArea1.setText(wyniki);

   }
   
     double obliczanieFisherka(int tab[]){
        
        
        
        double tSrA[][] = new double[tab.length][SampleCount[0]];
        double tSrB[][] = new double[tab.length][SampleCount[1]];
        double srA[] = new double[tab.length];
        double srB[] = new double[tab.length];
        double[][] mtA = new double[tab.length][SampleCount[0]];
        double[][] mtB = new double[tab.length][SampleCount[1]];
        double srO[] = new double[tab.length];
        int conA = 0, conB = 0;
   
for (int i = 0; i < FA2[0].length; i++) {
    for (int j = 0; j < tab.length; j++) {
        srA[j] += FA2[tab[j]][i];
        mtA[j][i] = FA2[tab[j]][i];

}
}
for (int i = 0; i < FB2[0].length; i++) {
    for (int j = 0; j < tab.length; j++) {
        srB[j] += FB2[tab[j]][i];
        mtB[j][i] = FB2[tab[j]][i];

}
}


       

        for (int j = 0; j < srA.length; j++) {
            
            srA[j] /= SampleCount[0];
            srB[j] /= SampleCount[1];
        }

        for (int j = 0; j < tab.length; j++) {
            for (int i = 0; i < SampleCount[0]; i++) {
                tSrA[j][i] = srA[j];
            }
            for (int i = 0; i < SampleCount[1]; i++) {
                tSrB[j][i] = srB[j];;
            }
        }

        Matrix A = new Matrix(mtA);
        Matrix B = new Matrix(mtB);
        Matrix sA2 = new Matrix(tSrA);
        Matrix sB2 = new Matrix(tSrB);

         Matrix maA;
        Matrix maB;
        
        maA = A.minus(sA2).times((A.minus(sA2)).transpose());
        maB = B.minus(sB2).times((B.minus(sB2)).transpose());

        double wyzA = maA.det();
        double wyzB = maB.det();


        for (int j = 0; j < srA.length; j++) {
            srO[j] = srA[j] - srB[j];
            
        }

        double gora = Math.pow((srO[0]), 2);
        for (int j = 1; j < srO.length; j++) {
            gora += Math.pow((srO[j]), 2);
        }
        gora = Math.sqrt(gora);
        double wynik =Math.abs(gora / (wyzA + wyzB));
        
        
        return wynik;
  
      
     }
     
     ///////////////Wszystkie mozliowosci
     
 static  List<int[]> listaBezPowt = new ArrayList<int[]>();

int[][] Wkomp;


	
static void genMozliwosci2(int[] mozliwosci, int wielkosc, int poczatek){
		
        
        for (int i = 0; i < FeatureCount; i++) {
           
            boolean stroz = true;
            for (int pow = 0; pow < poczatek; pow++) {
                if (i == mozliwosci[pow]) {
                    stroz = false;
                }
            }

            if (stroz) {
             
                mozliwosci[poczatek] = i;
            
                if (wielkosc - 1 == poczatek) {
                    int Nmozliwosci[] = new int[mozliwosci.length];
                    System.arraycopy(mozliwosci, 0, Nmozliwosci, 0, mozliwosci.length);
                    listaBezPowt.add(Nmozliwosci);
                } 
                else {
                    genMozliwosci2(mozliwosci, wielkosc, poczatek + 1);
                }
            }
        }
        }
		///konwertuje z listy do tablicy 2-d
    static int[][] genMozliwosci(int wielkosc){
        genMozliwosci2(new int[wielkosc], wielkosc, 0);
        int con=0;
        int[][] Wkomp = new int[listaBezPowt.size()][wielkosc];
        
		for(int[] line : listaBezPowt){
                    for(int i=0; i<wielkosc;i++){
                      
                        Wkomp[con][i]=line[i];
                        
                    }
                    con++;
                }
                listaBezPowt.clear();
                
                return Wkomp;
        }
    
	

	
	//////////////////////////////////SFS//////////////////////////////
		
   
 void SFS(int wymiar){
       
      genKlas(wymiar);
     
       int pierwszy=0,ind=0,naraz=0;
       int tabIndexow[]=new int[wymiar];
       double wynt=0,wynp=100;
       
        double FLD=0, tmp;
                  
            for(int i=0; i<FeatureCount; i++){
                if((tmp=computeFisherLD(F[i]))>FLD){
                    
                    FLD=tmp;
                    pierwszy = i;
                }
            }
            
            for(int i=0; i<wymiar;i++){
			tabIndexow[i]=i;
			
		}
            
            tabIndexow[0]=pierwszy;
            
             int tabt[]=new int[wymiar];
             int tabO[]=new int[wymiar];
             
             tabO[0]=pierwszy;
		
		for(int i=2; i<=tabIndexow.length;i++){
		
                        int tab[]=new int[i];
                        //zawsze zerowa wartosc bedzie stale
                      if(i==2){
                        tab[0]=pierwszy;
                        }
                    
                          for (int l=0; l<i-1;l++){
                               if(l==0){
                        tab[0]=pierwszy;
                        }else{
                             tab[l]=tabt[l];
                               }
                            }
                      
                        
                        boolean stroz =true; 
			for (int j=0; j<64;j++){
                            
                            stroz=true;
				for (int p=0; p<tab.length-1;p++){
                                    //elimunujemy powtorzenie
                                    if(tab[p]==j){
                                    stroz=false;
                                       
                                    }
                                }
                        
                                if(stroz==true ){
                                  
				tab[i-1]=j;
                                
                          
                                wynt=obliczanieFisherka(tab);
                              
                              
                           
                             if(naraz==0){
                                 naraz++;
                                 wynp=wynt;
                                 
                                 }
               
                          if(wynt>wynp){
                              wynp=wynt;
                              ind=j;
                              }
                            
                                
                        } 
                               
                        }
                       naraz=0;
                      
                       
                       
                        for (int k=0; k<tab.length;k++){
                            if(k==tab.length-1 ){
                                tabt[k]=ind;
                            }
                            else{
                            tabt[k]=tab[k];
                            }
                        }
                
                         for (int k=1; k<tab.length;k++){
                            tabO[k]=tabt[k];
                        }
 }
                              
           
            String wyniki = ("Klasyfikacjia SFS\n\nWygrały nastepujące cechy:   ") ;  
            
         Wynik = new int[tabIndexow.length]; 
          
           for (int i = 0; i < tabIndexow.length; i++) {
          
               Wynik[i]=tabO[i];
               wyniki+=tabO[i]+" ";
          
            
            
           }
           
               textArea1.setText(wyniki);
   
   }
 

 
 ///////////////////////////////////////CROSS////////////////////////////////////////////////
 /////////////////////////////GENEROWANIE ZBIORU///////////////////////////////////////////////////////////
 
 void genZbirBOOT(){
     int step = F[0].length/10;
     double[][] Testowy = new double[Wynik.length][step];
     double[][] Treningowy = new double[Wynik.length][9*step];
     int start=0,koniec=step;
     int[] Testprzy =new int[step];
     int[] Trenprzy =new int[F[0].length-4-step];
      int c=0,c2=0;
      double sredniaNN=0, sredniaNM=0,sredniakNN=0;
      int ilosc = Integer.parseInt(f_combo_criterion1.getSelectedItem().toString());
     

 
   do{
    for (int i = 0; i < Wynik.length; i++) {
       c=0;
       c2=0;
            for (int j = 0; j < 10*step; j++) {
                 
              if(j>=start && j<koniec){
                  
                  Testowy[i][c]=F[Wynik[i]][j];
                  c++;
              }
                          else{
                  Treningowy[i][c2]=F[Wynik[i]][j];
                  c2++;
      }
            }
    }

    c=0;
    c2=0;
     for (int i = 0; i < 10*step; i++) {
          
               if(i>=start && i<koniec){
                  Testprzy[c]=ClassLabels[i];
                  c++;
              }
               else{
                  Trenprzy[c2]=ClassLabels[i];
                  c2++;
              }
         
       }
     start=start+step;
     koniec=koniec+step;
     double wynik = NNFC(Testowy, Treningowy, Trenprzy, Testprzy);
     sredniaNN+=wynik;
  
     double wynik2 = NMFC(Testowy, Treningowy, Trenprzy, Testprzy);
     sredniaNM+=wynik2;
     
      double wynik3 =kNNFC(Testowy, Treningowy, Trenprzy, Testprzy, ilosc);
    
    sredniakNN+=wynik3;
   
 }while(koniec<=780);
         sredniaNN= sredniaNN/10.0;
         sredniaNM= sredniaNM/10.0;
         sredniakNN= sredniakNN/10.0;
    
   
     textArea1.setText("Srednia dla NN:    "+sredniaNN+" %\nSrednia dla NM:    "+sredniaNM+" %\nSrednia dla kNN:    "+sredniakNN+" %\nSrednia dla NM, NM oraz kNN:    "+((sredniaNM+sredniaNN+sredniakNN)/3.0)+" %");
 
 
 }
 
   public double NNFC(double[][] Testowy2,double[][] Treningowy2,int[] TreningowyPrzynaleznosc2,int[] TestowyPrzynaleznosc2 ){
        
        int znacznik=0;
        double result=0,win=0,poprawnosc=0;
  
        for(int i=0; Testowy2[0].length>i;i++){
            for(int j=0; Treningowy2[0].length>j;j++){
                for(int k=0; (Testowy2.length)>k;k++){
                 
                    result =result+Math.pow(Testowy2[k][i]-Treningowy2[k][j],2);
                }
       
            result=Math.sqrt(result);
            if(win==0){
                win=result;
                znacznik=TreningowyPrzynaleznosc2[j];
            }
            else if(result<win){
                win=result;
                znacznik=TreningowyPrzynaleznosc2[j];
            }
            result=0;
       }
           
           
            if(znacznik==TestowyPrzynaleznosc2[i]){poprawnosc++;};
            win=0;
            
    }
  
        
    double wynik=(poprawnosc/Testowy2[0].length)*100;
    return wynik;
    
    }
 
  public double NMFC(double[][] Testowy2,double[][] Treningowy2,int[] TreningowyPrzynaleznosc2,int[] TestowyPrzynaleznosc2){
           
          int znacznik=0;
        double result=0,win=0,poprawnosc=0, sredniaA=0,sredniaB=0,countA=0,countB=0;

        
  
        for(int i=0; Testowy2[0].length>i;i++){
            for(int j=0; Treningowy2[0].length>j;j++){
                for(int k=0; (Testowy2.length)>k;k++){
                 
                    result =result+Math.pow(Testowy2[k][i]-Treningowy2[k][j],2);
                }
       
            result=Math.sqrt(result);
            
            if (TreningowyPrzynaleznosc2[j]==0)
            {
                sredniaA=sredniaA+result;
                countA++;
            }
            else{
                sredniaB=sredniaB+result;
                countB++;
            }
           
            result=0;
       }
            sredniaA=sredniaA/countA;
            sredniaB=sredniaB/countB;
                if(sredniaA<sredniaB){
                win=sredniaA;
                znacznik=0;
            }
            else{
                 win=sredniaB;
                 znacznik=1;
            }
                    if(znacznik==TestowyPrzynaleznosc2[i]){poprawnosc++;};
            win=0;
            sredniaA=0;
            sredniaB=0;
             countA=0;
              countB=0;
            
        }
         double wynik=(poprawnosc/Testowy[0].length)*100;
      
      return wynik;   
 }
 
   public double kNNFC(double[][] Testowy2,double[][] Treningowy2,int[] TreningowyPrzynaleznosc2,int[] TestowyPrzynaleznosc2,int kwyg){
       int counterwypelnienia=0; 
        int znacznik=0;
        double[] tabwin = new double[kwyg];
        int[] tabwinznacznik = new int[kwyg];
        double result=0,winA=0, winB=0,poprawnosc=0;
        
       
  
        for(int i=0; Testowy2[0].length>i;i++){
            for(int j=0; Treningowy2[0].length>j;j++){
                for(int k=0; (Testowy2.length)>k;k++){
                 
                    result =result+Math.pow(Testowy2[k][i]-Treningowy2[k][j],2);
                }
       
            result=Math.sqrt(result);
            
            if(counterwypelnienia<kwyg){
                tabwin[counterwypelnienia]=result;
                tabwinznacznik[counterwypelnienia]=TreningowyPrzynaleznosc2[j];
                counterwypelnienia++;
                  
            }
            else { 
                         
                sortowaniezwy(tabwin, tabwinznacznik );
                if( tabwin[kwyg-1]>result){
                tabwin[kwyg-1]=result;
                tabwinznacznik[kwyg-1]=TreningowyPrzynaleznosc2[j];
                }
            }
            result=0;
            }
            
            for (int t=0;tabwinznacznik.length>t;t++)
            {
            if(tabwinznacznik[t]==0){
                winA++;
            }else{
            winB++;
           
            }
            }
            if (winA>winB){
                znacznik=0;
            }else{
            znacznik=1;
            }
      
            if(znacznik==TestowyPrzynaleznosc2[i]){poprawnosc++;  
       
           
            }
            winA=0;
            winB=0;
              counterwypelnienia=0;  
    }
        
    double wynik=(poprawnosc/Testowy[0].length)*100;
    return wynik;
    
    }
   


    private double computeFisherLD(double[] vec) {
        // 1D, 2-classes
        double mA=0, mB=0, sA=0, sB=0;
        for(int i=0; i<vec.length; i++){
            if(ClassLabels[i]==0) {
                mA += vec[i];
                sA += vec[i]*vec[i];
            }
            else {
                mB += vec[i];
                sB += vec[i]*vec[i];
            }
        }
        mA /= SampleCount[0];
        mB /= SampleCount[1];
        sA = sA/SampleCount[0] - mA*mA;
        sB = sB/SampleCount[1] - mB*mB;
        return Math.abs(mA-mB)/(Math.sqrt(sA)+Math.sqrt(sB));
    }
    
      

    private Matrix extractFeatures(Matrix C, double Ek, int k) {               
        
      Matrix evecs, evals;
        // compute eigenvalues and eigenvectors
        evecs = C.eig().getV();
        evals = C.eig().getD();

        // PM: projection matrix that will hold a set dominant eigenvectors
        Matrix PM;
        if (k > 0) {
            // preset dimension of new feature space
//            PM = new double[evecs.getRowDimension()][k];
            PM = evecs.getMatrix(0, evecs.getRowDimension() - 1,
                    evecs.getColumnDimension() - k, evecs.getColumnDimension() - 1);
        } else {
            // dimension will be determined based on scatter energy
            double TotEVal = evals.trace(); // total energy
            double EAccum = 0;
            int m = evals.getColumnDimension() - 1;
            while (EAccum < Ek * TotEVal) {
                EAccum += evals.get(m, m);
                m--;
            }
            PM = evecs.getMatrix(0, evecs.getRowDimension() - 1, m + 1, evecs.getColumnDimension() - 1);
        }

        
        return PM;
    }

    private Matrix computeCovarianceMatrix(double[][] m) {
//        double[][] C = new double[M.length][M.length];
        
        Matrix M = new Matrix(m);
        Matrix MT = M.transpose();       
        Matrix C = M.times(MT);
        return C;
    }

    private double[][] centerAroundMean(double[][] M) {
        
        double[] mean = new double[M.length];
        for(int i=0; i<M.length; i++)
            for(int j=0; j<M[0].length; j++)
                mean[i]+=M[i][j];
        for(int  i=0; i<M.length; i++) mean[i]/=M[0].length;
        for(int i=0; i<M.length; i++)
            for(int j=0; j<M[0].length; j++)
                M[i][j]-=mean[i];
        return M;
    }

    private double[][] projectSamples(Matrix FOld, Matrix TransformMat) {
        
        return (FOld.transpose().times(TransformMat)).transpose().getArrayCopy();
    }
}


class Classifier {
    
   double[][] TrainingSet, TestSet;
     int[] ClassLabels;
    final int TRAIN_SET=0, TEST_SET=1;
    
    void generateTraining_and_Test_Sets(double[][] Dataset, String TrainSetSize, int[] najlepsze){

        
        int[] Index = new int[Dataset[0].length];
        double Th = Double.parseDouble(TrainSetSize)/100.0;
        int TrainCount=0, TestCount=0;
        for(int i=0; i<Dataset[0].length; i++) 
            if(Math.random()<=Th) {
                Index[i]=TRAIN_SET;
                TrainCount++;
            }
            else {
                Index[i]=TEST_SET;
                TestCount++;
            }   
        TrainingSet = new double[Dataset.length][TrainCount];
        TestSet = new double[Dataset.length][TestCount];
        TrainCount=0;
        TestCount=0;
        // label vectors for training/test sets
        for(int i=0; i<Index.length; i++){
            if(Index[i]==TRAIN_SET){
                System.arraycopy(Dataset[i], 0, TrainingSet[TrainCount++], 0, Dataset[0].length);
            }
            else
                System.arraycopy(Dataset[i], 0, TestSet[TestCount++], 0, Dataset[0].length);                
        }
    }
    
    protected void trainClissifier(double[][] TrainSet){
        




}

class NNClassifier extends Classifier {
    
    
     
    @Override
    protected void trainClissifier(double[][] TrainSet){
    
    }
}
}